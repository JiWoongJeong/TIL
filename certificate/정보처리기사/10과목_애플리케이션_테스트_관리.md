[TOC]



## 10. 애플리케이션 테스트 관리

### 1. 애플리케이션 테스트 케이스 설계

#### 1. 애플리케이션 테스트 케이스 작성

- 소프트웨어 테스트 이해

  - 개념 : 사용자 요구사항 만족 + 숨어있는 결함

  - 필요성 : **발예향** - 오류 발견 관점, 오류 예방 관점, 품질 향상 관점

  - 기본 원칙

    - 원리 : **결완초집 살정오**

      |          원리           |                             설명                             |
      | :---------------------: | :----------------------------------------------------------: |
      |       결함이 존재       |                                                              |
      |  완벽한 테스팅 불가능   |                    무한 경로, 무한 입력값                    |
      | 개발 초기에 테스팅 시작 |               요르돈의 법칙 (나중에 비용 커짐)               |
      |        결함집중         |             파레토 법칙 (오류 80%는 전체 20% 내)             |
      |     살충제 패러독스     | 동일 반복 테스트 -> 새로운 버그 X<br />반복 테스트 X, 다른 시각 접근, 정기적 리뷰 |
      |       정황에 의존       |       소프트웨어 성격에 맞게 -> 정황, 비즈니스 도메인        |
      |    오류-부재의 궤변     |                        요구사항 충족                         |

    - 산출물

      - 테스트 시나리오 : 테스트 필요 기능, 특징, 상황 작성 문서, 테스트 케이스 일대다 관계
      - 테스트 슈트 (Suit) : 실행환경에 따라 구분, 시나리오 포함 X 단순 테스트 케이스
      - 테스트 스크립트 / 스탭 / 절차서 (Script) : 테스트 케이스 실행 순서

- 소프트웨어 테스트 유형

  - 프로그램 실행 여부

    |    분류     |       설명        |              유형               |
    | :---------: | :---------------: | :-----------------------------: |
    | 정적 테스트 | 실행 X, 구조 분석 |         리뷰, 정적 분석         |
    | 동적 테스트 | 실행 -> 결함 검출 | 화이트박스, 블랙박스, 경험 기반 |

    - 리뷰 : 관리 리뷰, 기술 리뷰, 인스펙션, 워크스루, 감사
      - 인스펙션 : 주재자

  - 테스트 기법

    - 화이트박스 테스트 유형 : **구결조 조변다 기제데**, 내부 구조, 동작 검사

      |                            유형                            |                             내용                             |
      | :--------------------------------------------------------: | :----------------------------------------------------------: |
      |            구문/문장 커버리지<br />(Statement)             | 모든 명령문 최소 1회 수행<br />결과 상관 없이 구문 실행 개수 |
      |      결정/선택/분기 커버리지<br />(Decision, Branch)       | 전체 조건식 최소 1회 참/거짓 결과 수행<br />구문 커버리지 포함 |
      |               조건 커버리지<br />(Condition)               | 개별 조건식 최소 1회 참/거짓 결과 수행<br />구문 커버리지 포함 |
      |        조건/결정 커버리지<br />(Condition/Decision)        |         전체, 개별 조건식 참 1회, 거짓 1회 결과 수행         |
      | 변경 조건/결정 커버리지<br />(Modified Condition/Decision) | 개별 -> 전체 조건식에 독립적 영향<br />조건/결정 커버리지 향상 |
      |        다중 조건 커버리지<br />(Multiple Condition)        |            모든 개별 조건식 가능한 조합 100% 보장            |
      |            기본 경로 커버리지<br />(Base Path)             |                    수행 가능한 모든 경로                     |
      |            제어 흐름 테스트<br />(Control Flow)            |    프로그램 제어 구조 -> 그래프 형태 => 내부 로직 테스트     |
      |            데이터 흐름 테스트<br />(Data Flow)             |              제어 흐름 그래프 + 데이터 사용현황              |

    - 블랙박스 테스트 : **동경결상 유분페원비**, 외부 사용자 요구사항 명세

      |                             유형                             |                             내용                             |
      | :----------------------------------------------------------: | :----------------------------------------------------------: |
      | 동등/동치/균등 분할 / 동치 클래스 분해 테스트<br />(Equivalence Partitioning) | 입력 데이터 영역 -> 유사 도메인별 유/무효값 그룹핑<br />=> 대푯값 테스트 케이스 도출 |
      |  경계값 분석 / 한곗값 테스트<br />(Boundary Value Analysis)  | 경곗값 포함 -> 입력값 극한 한계 테스트<br />(최솟값 바로 위, 최댓값 바로 아래) |
      |              결정 테이블 테스트<br />(Decision)              | 요구사항 논리, 발생조건 테이블 형태 나열<br />-> 조건, 행위 모두 조합 |
      |           상태 전이 테스트<br />(State Transition)           | 대상/시스템, 객체 상태 구분<br />-> 이벤트 : 상태 전이 경우의 수 |
      |                      유스케이스 테스트                       | 실제 사용 유스케이스로 모델링<br />-> 프로세스 흐름 기반 테스트 케이스 명세화 |
      |      분류 트리 테스트<br />(Classification Tree Method)      |                    트리 구조로 분석, 표현                    |
      |              페어와이즈 테스트<br />(Pairwise)               | 테스트 데이터 값 간 최소 1회 조합<br />-> 커버 기능 범위 : 적은 양 테스트 세트 구성 |
      |     원인-결과 그래프 테스트<br />(Cause-Effect Graphing)     | 그래프 -> 입력 데이터 관계, 출력에 영향 분석<br />=> 효용성 높은 테스트 케이스 선정 |
      |                비교 테스트<br />(Comparison)                 |          같은 입력값 -> 동일 결과 데이터 산출 여부           |

  - 테스트 시각

    - 검증 (Verification) : 개발 과정
    - 확인 (Validation) : 결과

  - 테스트 목적 : **회안성 구회병**

    |              분류              |               설명                |
    | :----------------------------: | :-------------------------------: |
    |  회복 테스트<br />(Recovery)   |   고의 실패 -> 정상적 복귀 여부   |
    |  안전 테스트<br />(Security)   |        보안 결함 미리 점검        |
    | 성능 테스트<br />(Performance) | 응답 시간, 처리 업무량, 반응 속도 |
    |  구조 테스트<br />(Structure)  | 내부 논리 경로, 소스 코드 복잡도  |
    | 회귀 테스트<br />(Regression)  |  오류 제거, 확인 -> 반복 테스트   |
    |  병행 테스트<br />(Parallel)   |   동일 데이터 입력 -> 결과 비교   |

    - 성능 테스트 : **부스스내**

      |              유형              |                  설명                  |
      | :----------------------------: | :------------------------------------: |
      |    부하 테스트<br />(Load)     | 부하 계속 증가 -> 임계점, 병목 현상 X  |
      |        스트레스 테스트         | 임계점 이상 부하 -> 비정상적 상황 처리 |
      |        스파이크 테스트         |        짧은 시간 사용자 몰릴 때        |
      | 내구성 테스트<br />(Endurance) |           오랫동안 높은 부하           |

  - 종류 : **명구경**

    |                분류                |                           설명                            |                      유형                       |
    | :--------------------------------: | :-------------------------------------------------------: | :---------------------------------------------: |
    |  명세 기반 테스트<br />(블랙박스)  |                   요구사항 명세서 기반                    |                                                 |
    | 구조 기반 테스트<br />(화이트박스) |                      내부 논리 흐름                       |                                                 |
    |  경험 기반 테스트<br />(블랙박스)  | 유사 SW, 기술 평가 -> 테스터 경험 기반 => 직관, 기술 능력 | 탐색적, 오류추정, <br />체크리스트, 특정 테스트 |

- 동적 테스트

  - 화이트박스 테스트 (구조 기반 테스트)

    - 테스트 커버리지 : 테스트 수행 정도 -> 완벽성

      - 유형 : **기라코**

        |        유형        |                             설명                             |
        | :----------------: | :----------------------------------------------------------: |
        | 기능 기반 커버리지 | 전체 기능 모수 -> 실제 테스트 수행 기능 수 측정<br />100% 달성 목표, UI 많으면 -> 화면 수 모수 |
        |   라인 커버리지    | 전체 소스 코드 수 모수 -> 테스트 시나리오 수행 소스 코드 라인 수 측정<br />단위 테스트에서 척도 |
        |   코드 커버리지    |  테스트 충분성 지표 -> 구조 코드 자체가 얼마나 테스트 수행   |

  - 경험 기반 테스트

    - 유형

      |               유형               |                             설명                             |
      | :------------------------------: | :----------------------------------------------------------: |
      | 탐색적 테스트<br />(Exploratory) | 중대한 테스트, 휴리스틱한 능력 필요<br />테스트 차터, 시간 제한, 노트, 회고 |
      | 오류 추정<br />(Error Guessing)  | + 명세 기반 테스트 -> 보완 시<br />예상 X 상황 -> 입력값 처리 여부 |
      |            체크리스트            |                 분류, 나열 -> 목록화, 재사용                 |
      |            특성테스트            |                          품질 특성                           |

- 테스트 오라클 : 사전에 정의된 참 값 입력

  - 종류 : **참샘휴일**

    |               유형               |                           설명                           |
    | :------------------------------: | :------------------------------------------------------: |
    |            참 오라클             |    모든 입력값 기대 결과 생성 -> 발생 오류 모두 검출     |
    |          샘플링 오라클           |               특정 입력값만 기대 결과 제공               |
    | 휴리스틱 오라클<br />(Heuristic) | 샘플링 개선 -> 특정 입력값 올바른 결과, 나머지 추정 처리 |
    |        일관성 검사 오라클        |         변경 시 수행 전후 결괏값 동일 여부 확인          |

#### 2. 애플리케이션 테스트 시나리오 작성

- 테스트 레벨

  - 종류

    |     종류      |                            설명                            |                          기법                          |
    | :-----------: | :--------------------------------------------------------: | :----------------------------------------------------: |
    |  단위 테스트  |           사용자 요구사항 -> 단위 모듈, 서브루틴           | 자료 구조, 실행 경로<br />오류 처리, 인터페이스 테스트 |
    |  통합 테스트  | 단위 테스트 통과 <br />-> 인터페이스, 컴포넌트 간 상호작용 |           빅뱅, 샌드위치, 상향/하향식 테스트           |
    | 시스템 테스트 |             통합 단위 시스템 -> 정상 수행 여부             |              기능/비기능 요구사항 테스트               |
    |  인수 테스트  |               계약상 요구사항 만족 여부 확인               |   계약/규정/사용자/운영 인수<br />알파, 베타 테스트    |

### 2. 애플리케이션 통합 테스트

#### 1. 애플리케이션 테스트 수행

- 단위 테스트

  - 목 (Mock) 객체 생성 프레임워크

    - 유형 : **더스드 스가**

      |        유형        |                             설명                             |
      | :----------------: | :----------------------------------------------------------: |
      | 더미 객체 (Dummy)  | 객체만 필요, 기능 필요 X 시<br />메서드 호출 -> 정상 동작 수행 X, 예외 수행 |
      | 테스트 스텁 (Stub) | 제어 모듈 호출 타 모듈 기능 수행<br />더미 객체 단순 기능 + 특정 상태 가정 -> 특정 값 리턴, 메시지 출력 |
      |  테스트 드라이버   | 하위 모듈 호출, 파라미터 전달, 모듈 테스트 수행 후 결과 도출 |
      |   테스트 스파이    |                협력 클래스 -> 가는 출력 검증                 |
      |  가짜 객체 (Fake)  |        실제 협력 클래스 기능 대체 시 -> 단순하게 구현        |

- 통합 테스트 : **하스 상드** (하향식 스텁, 상향식 드라이버)

  - 샌드위치 통합 : 상향식 + 하향식 -> 큰 규모, 병렬 테스트, 시간 절약, 비용 많이 소요

- 테스트 자동화 도구: 

  - 유형 : **정실성통**

    - 정적 분석 도구 (Static Analysis Tools) : 실행 X 분석
    - 테스트 실행 도구 (Test Execution Tools) : 스크립트 실행 - 특정 데이터, 수행 방법 포함
      - 데이터, 키워드 주도 접근 방식
    - 성능 테스트 도구 (Performance) : 가상 사용자 -> 처리량, 응답/경과 시간, 자원 사용률
    - 테스트 통제 도구 (Test Control) : 다른 도구 연계 

  - 테스트 하네스 : 환경 일부분 -> 테스트 지원 코드, 데이터 => 단위, 모듈 테스ㅡ

    - 구성요소 : **드 스슈케 스목**

      |    구성요소     |                             설명                             |
      | :-------------: | :----------------------------------------------------------: |
      | 테스트 드라이버 | 하위 모듈 호출, 파라미터 전달, 모듈 테스트 수행 후 결과 도출<br />-> 상향식 테스트 |
      |   테스트 스텁   |      제어 모듈 호출 타 모듈 기능 수행 -> 하향식 테스트       |
      |   테스트 슈트   |     대상 컴포넌트, 모듈, 시스템 사용 테스트 케이스 집합      |
      |  테스트 케이스  |              입력값, 실행 조건, 기대 결과 집합               |
      | 테스트 스크립트 |                   자동화된 실행 절차 명세                    |
      |   목 오브젝트   |        사용자 행위 조건부 사전 입력 -> 예정 행위 수행        |

#### 2. 애플리케이션 테스트 결과 분석

- 테스트 결과 분석

  - 결함 (Defect)

    |      구분      |                             설명                             |
    | :------------: | :----------------------------------------------------------: |
    |   에러/오류    |                결함 원인 -> 사람이 만든 실수                 |
    | 결함/결점/버그 | 에러, 오류 -> 제품에 포함 <br />=> 실패 (Failure), 문제 (Problem) |
    |   실패/문제    |                          결함 실행                           |

  - 테스트 리포팅 : **정요품 결실**

    |            구분             |                          설명                          |
    | :-------------------------: | :----------------------------------------------------: |
    |      테스트 결과 정리       |             계획 ~ 설계 ~ 시나리오 ~ 결과              |
    |       테스트 요약문서       |              테스트 계획, 소요 비용, 결과              |
    |          품질 상태          | 테스트 성공률, 커버리지<br />발생 결함 수, 결함 중요도 |
    |        테스트 결과서        |           결함 -> 내용, 자원 정보, 재현 순서           |
    | 테스트 실행 절차 리뷰, 평가 |                                                        |

- 결함 관리

  - 프로세스 : **계기검수 재추최**
    - 결함 관리 계획 -> 기록 -> 검토 -> 수정 -> 재확인 -> 상태 추적, 모니터링 -> 최종 분석, 보고서 작성
  - 분석
    - 방법 : 구체화, 고립화, 일반화

- 결함 추이 분석 : 테스트 완료 후 발견 결함 -> 관리 측정 지표 속성값 분석, 향후 결함 발생 추정

  - 분포, 추세, 에이징 분석

#### 3. 애플리케이션 개선 조치사항 작성

- 테스트 커버리지 : **기라코**

- 결함 식별, 관리

  - 분류 : **시기지문**

    |    유형     |              설명              |
    | :---------: | :----------------------------: |
    | 시스템 결함 |        앱 환경, DB 처리        |
    |  기능 결함  | 기획, 설계, 업무 시나리오 단계 |
    |  GUI 결함   |        사용자 화면 설계        |
    |  문서 결함  |     의사소통, 기록 원활 X      |

  - 심각도별 분류

    |          분류          |                         설명                         |
    | :--------------------: | :--------------------------------------------------: |
    | 치명적 결함 (Critical) |                        완전히                        |
    |   주요 결함 (Major)    |                  기대와 많이 다르게                  |
    |   보통 결함 (Normal)   | 특정 기준 충족 X<br />전체에 영향 X 일부 기능 부자연 |
    |  경미한 결함 (Minor)   |                    사용상 불편함                     |
    |   단순 결함 (Simple)   |                기능 영향 X, 수정 필요                |

### 3. 애플리케이션 성능 개선

#### 1. 애플리케이션 성능 분석

- 점검 개요

  - 지표 : **처응경자**

    |               지표                |                             설명                             |
    | :-------------------------------: | :----------------------------------------------------------: |
    |     처리량<br />(Throughput)      |         처리 트랜잭션 수<br />웹 -> 시간당 페이지 수         |
    |  응답 시간<br />(Response Time)   | 사용자 입력 후 앱 응답 출력 시작 시간<br />앱 -> 메뉴 나타나는 시간 |
    | 경과 시간<br />(Turnaround TIme)  |       요구 입력 시점 ~ 트랜잭션 처리 후 출력 완료 시간       |
    | 자원 사용률<br />(Resource Usage) |      트랜잭션 처리 중 사용 CPU, 메모리, 네트워크 사용량      |

  - 분석 도구

    - 성능/부하/스트레스 점검 도구
    - 모니터링 도구

- 성능 저하 원인

  - DB : **락페릭사커**

    |                        구분                         |                             설명                             |
    | :-------------------------------------------------: | :----------------------------------------------------------: |
    |                        DB 락                        | 대량 데이터 조회, 과도 업데이트, 인덱스 생성<br />Lock 해제까지 대기, 타임 아웃 |
    |               불필요 DB 패치 (Fetch)                | 대량 데이터 요청<br />결과 세트에서 마지막 위치로 커서 이동 작업 빈번 시 |
    |          연결 누수<br />(Connection Leak)           |                 JDBC 객체 사용 후 미 종료 시                 |
    | 부적절한 커넥션 풀 크기<br />(Connection Pool Size) |                    너무 작거나 크게 설정                     |
    |                    확정 (Commit)                    |            확정 X 커넥션 풀에 반환, 불필요한 확정            |

- 성능 테스트 프로세스

  - 수행 절차 : **도환시성**
    - 성능 테스트 도구 설치 -> 테스트 환경 설정 -> 시나리오 생성 -> 성능 테스트 실행, 모니터링
      - 시나리오 생성 : 부하 형태, 파라미터, 사용자 수, Ramp-up load, 수행 시간, 모니터링 결과 저장 파일

#### 2. 애플리케이션 성능 개선

- 소스 코드 최적화

  - 베드 코드 (Bad Code)

    - 사례
      - 외계인 코드 : 아주 old, 참고문서 or 개발 X
      - 스파게티 코드 : 복잡 
    - 유형 : **오문이 결침**
      - 오염, 문서 부족, 의미 없는 이름, 높은 결합도 (복잡 연결), 아키텍처 침식

  - 클린 코드 (Clean Code)

    - 작성 원치 : **가단의 중추**

      |  작성 원칙  |                             설명                             |
      | :---------: | :----------------------------------------------------------: |
      |   가독성    |                 이해하기 쉬운 용어, 들여쓰기                 |
      |   단순성    | 한 번에 한 가지 처리만 수행<br />클래스 / 메서드/ 함수 최소 단위 분리 |
      | 의존성 최소 |                                                              |
      | 중복성 제거 |                                                              |
      |   추상화    |           동일 수준 추상화 -> 상세 : 하위에서 구현           |

- 성능 개선 방안

  - 리팩토링 : 기능 변경 X, 복잡 코드 단순화, 소스 가독성
    - 목적 : 유지보수성, 유연한 시스템, 생산성, 품질