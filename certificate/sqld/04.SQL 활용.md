[TOC]

## 2과목. SQL 기본 및 활용

### 제2장. SQL 활용

#### 제1절 표준 조인

- 순수 관계 연산자

  - SELECT, PROJECT, JOIN, DIVIDE
  - SQL 문장 비교
    - SELECT : WHERE 절로 구현
    - PROJECT : SELECT 절로 구현
    - JOIN : 다양한 JOIN 기능으로 구현
    - DIVIDE : 현재 사용 X

- FROM 절 JOIN 형태

  - 문제

    > SQL -> ANSI 표준 구문
    >
    > [게시판] 게시판ID - 게시판명, 등록일시, 사용여부 ~ [게시글] 게시글ID - 게시판ID (FK), 제목, 내용, 등록일시, 등록자명, 삭제여부
    >
    > ```sql
    > SELECT A.게시판ID, A.게시판명, COUNT(B.게시글ID) AS CNT FROM 게시판 A, 게시글 B 
    > WHERE A.게시판ID = B.게시판ID(+) AND B.삭제여부(+) = 'N' AND A.사용여부 = 'Y'
    > GROUP BY A.게시판ID, A.게시판명 ORDER BY A.게시판ID;
    > ```

    ```sql
    SELECT A.게시판ID, A.게시판명, COUNT(B.게시글ID) AS CNT
    FROM 게시판 A LEFT OUTER JOIN 게시글 B
    ON (A.게시판ID = B.게시판ID AND B.삭제여부 = 'N') WHERE A.사용여부 = 'Y'
    GROUP BY A.게시판ID, A.게시판명 ORDER BY A.게시판ID;
    ```

  - INNER JOIN

    - OUTER JOIN 대비 -> 내부 조인, JOIN 조건에서 동일 값 있는 행만 반환

    - 문제

      > [고객] 고객ID - 고객명, 나이 ~ [추천컨텐츠] 고객ID (FK), 컨텐츠ID (FK) - 추천대상일자
      >
      > [고객] ~ [비선호컨텐츠] 고객ID (FK), 컨텐츠ID (FK) - 등록일시 ~ [컨텐츠] 컨텐츠ID - 컨텐츠명
      >
      > 추천 대상일자 -> 해당일자에만 컨텐츠 추천, 선호 컨텐츠 X -> 비선호 컨텐츠 => 추천 X

      ```sql
      SELECT C.컨텐츠ID, C.컨텐츠명 
      FROM 고객 A INNER JOIN 추천컨텐츠 B 
      ON (A.고객ID = B.고객ID) INNER JOIN 컨텐츠 C
      ON (B.컨텐츠ID = C.컨텐츠ID) LEFT OUTER JOIN 비선호컨텐츠 D
      ON (B.고객ID = D.고객ID AND B.컨텐츠ID = D.컨텐츠ID)
      WHERE A.고객ID = #custId#
      AND B.추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD')
      AND D.컨텐츠ID IS NULL;
      ```

      ```sql
      SELECT C.컨텐츠ID, C.컨텐츠명
      FROM 고객 A INNER JOIN 추천컨텐츠 B
      ON (A.고객ID = #custId# AND A,고객ID = B.고객ID) INNER JOIN 컨텐츠 C
      ON (B.컨텐츠ID = C.컨텐츠ID)
      WHERE B.추천대상일자 = TO_CHAR(SYSDATE, 'YYYY.MM.DD')
      AND NOT EXISTS (SELECT X.컨텐츠ID FROM 비선호컨텐츠 X WHERE X.고객ID = B.고객ID AND X.컨텐츠ID = B.컨텐츠ID);
      ```

    - 문제

      > [제품] 제품코드 - 제품명, 제품유형코드, 단위 ~ [생산제품] 라인번호 (FK), 제품코드 (FK) ~ [생산라인] 라인번호 - 최초가동일자

      - INNER JOIN -> 생산제품 엔터티 : WHERE 절에 최소 2번
      - 제품 ~ 생산라인 엔터티 JOIN : 적절한 JOIN 조건 X -> CARTESIAN PRODUCT 발생 (양쪽 집합 M*N 데이터 조합)

    - 문제

      > 구매 이력이 있는 고객 중 구매 횟수가 3회 이상인 고객의 이름과 등급
      >
      > 고객(고객번호(PK), 이름, 등급)
      >
      > 구매정보(구매번호(PK), 구매금액, 고객번호(FK))
      >
      > ```sql
      > SELECT A.이름, A.등급 FROM 고객 A (a) GROUP BY A.이름, A.등급 (b)
      > ```

      ```sql
      SELECT A.이름, A.등급 
      FROM 고객 A INNER JOIN 구매정보 B ON A.고객번호 = B.고객번호 
      GROUP BY A.이름, A.등급 HAVING COUNT(B, 구매번호) >= 3
      ```

    - 문제

      > 시간대별 사용량 기반 -> 고객별 사용금액
      >
      > [시간대구간] 시작시간대, 종료시간대 - 단가 ~ [시간대별사용량] 고객ID (FK), 사용시간대 - 사용량 ~ [고객] 고객ID - 고객명, 생년월일

      ```sql
      SELECT A.고객ID, A.고객명, SUM(B.사용량 * C.단가) AS 사용금액
      FROM 고객 A INNER JOIN 시간대별사용량 B
      ON (A.고객ID = B.고객ID) INNER JOIN 시간대구간 C
      ON B.사용시간대 BETWEEN C.시작시간대 AND C.종료시간대
      GROUP BY A.고객ID, A.고객명
      ORDER BY A.고객ID, A.고객명
      ```

  - NATURAL JOIN

  - USING 조건절

    - 문제 : 소속팀 전용구장, 팀 정보

      ```sql
      SELECT T.REGION_NAME, T.TEAM_NAME, STADIUM_ID, S.STADIUM_NAME FROM TEAM T INNER JOIN STADIUM S USING STADIUM_ID;
      
      SELECT TEAM.REGION_NAME, TEAM.TEAM_NAME, TEAM.STADIUM_ID, STADIUM.STADIUM_NAME FROM TEAM INNER JOIN STADIUM ON (TEAM.STADIUM_ID = STADIUM.STADIUM_ID);
      
      SELECT T.REGION_NAME, T.TEAM_NAME, T.STADIUM_ID, S.STADIUM_NAME FROM TEAM T, STADIUM S WHERE T.STADIUM_ID = S.STADIUM_ID;
      
      SELECT TEAM.REGION_NAME, TEAM.TEAM_NAME, TEAM.STADIUM_ID, STADIUM.STADIUM_NAME FROM TEAM, STADIUM WHERE TEAM.STADIUM_ID = STADIUM.STADIUM_ID;
      ```

  - ON 조건절

  - CROSS JOIN 

    - 테이블 간 JOIN 조건 X 생길 수 있는 모든 데이터 조합 -> 조건절 X / CROSS JOIN 키워드로 사용

    - 문제 : CARTESIAN PRODUCT

      ```sql
      SELECT ENAME, DNAME FROM EMP, DEPT ORDER BY ENAME;
      
      /* SAME */
      SELECT ENAME, DNAME FROM EMP CROSS JOIN DEPT ORDER BY ENAME;
      ```

  - OUTER JOIN (LEFT, RIGHT, FULL)

    - LEFT

      ```sql
      SELECT X.KEY1, Y.KEY2 FROM TAB1 X LEFT OUTER JOIN TAB2 Y ON (X.KEY = Y.KEY2)
      ```

      - 좌측 테이블 데이터 먼저, 우측 테이블에서 JOIN 대상 데이터

      - B JOIN 칼럼에서 같은 값 있을 때 해당 데이터 가져오기, 없으면 NULL 값으로 채움

      - 문제

        > - OS
        >
        >   | OSID (PK) |  OS명   |
        >   | :-------: | :-----: |
        >   |    100    | Android |
        >   |    200    |   iOS   |
        >   |    300    |  Bada   |
        >
        > - 단말기
        >
        >   | 단말기ID (PK) | 단말기명 | OSID (FK) |
        >   | :-----------: | :------: | :-------: |
        >   |     1000      |  A1000   |    100    |
        >   |     2000      |  B2000   |    100    |
        >   |     3000      |  C3000   |    200    |
        >   |     4000      |  D3000   |    300    |
        >
        > - 고객
        >
        >   | 고객번호 (PK) | 고객명 | 단말기ID (FK) |
        >   | :-----------: | :----: | :-----------: |
        >   |     11000     | 홍길동 |     1000      |
        >   |     12000     | 강감찬 |     NULL      |
        >   |     13000     | 이순신 |     NULL      |
        >   |     14000     | 안중근 |     3000      |
        >   |     15000     | 고길동 |     4000      |
        >   |     16000     | 이대로 |     4000      |
        >
        > ```sql
        > SELECT A.고객번호, A.고객명, B.단말기ID, B.단말기명, C.OSID, C.OS명
        > FROM 고객 A LEFT OUTER JOIN 단말기 B
        > ON (A.고객번호 IN (11000, 12000) AND A.단말기ID = B.단말기ID) LEFT OUTER JOIN OS C
        > ON (B.OSID = C.OSID)
        > ORDER BY A. 고객번호;
        > ```

        | 고객번호 | 고객명 | 단말기ID | 단말기명 | OSID |  OS명   |
        | :------: | :----: | :------: | :------: | :--: | :-----: |
        |  11000   | 홍길동 |   1000   |  A1000   | 100  | Android |
        |  12000   | 강간찬 |   NULL   |   NULL   | NULL |  NULL   |
        |  13000   | 이순신 |   NULL   |   NULL   | NULL |  NULL   |
        |  14000   | 안중근 |   NULL   |   NULL   | NULL |  NULL   |
        |  15000   | 고길동 |   NULL   |   NULL   | NULL |  NULL   |
        |  16000   | 이대로 |   NULL   |   NULL   | NULL |  NULL   |

      - 문제 : 일시적으로 사원 없는 경우 O, 사원 없는 부서 정보도 출력

        ```sql
        SELECT E.ENAME, D.DEPTNO, D.DNAME FROM DEPT LEFT OUTER JOIN EMP E ON D.DEPTNO = E.DEPTNO;
        ```

      - 문제

        > - TAB1
        >
        >   |  C1  |  C3  |
        >   | :--: | :--: |
        >   |  A   |  1   |
        >   |  B   |  2   |
        >   |  C   |  3   |
        >   |  D   |  4   |
        >   |  E   |  5   |
        >
        > - TAB2
        >
        >   |  C1  |  C2  |
        >   | :--: | :--: |
        >   |  B   |  2   |
        >   |  C   |  3   |
        >   |  D   |  4   |
        >
        > ```sql
        > SELECT * FROM TAB1 A LEFT OUTER JOIN TAB2 B ON (A.C1 = B.C1 AND B.C2 BETWEEN 1 AND 3)
        > ```

        |  C1  |  C2  |  C1  |  C2  |
        | :--: | :--: | :--: | :--: |
        |  A   |  1   |      |      |
        |  B   |  2   |  B   |  2   |
        |  C   |  3   |  C   |  3   |
        |  D   |  4   |  D   |  4   |
        |  E   |  5   |      |      |

    - RIGHT

      ```sql
      SELECT X.KEY1, Y.KEY2 FROM TAB1 X RIGHT OUTER JOIN TAB2 Y ON (X.KEY = Y.KEY2)
      ```

    - FULL

      ```sql
      SELECT X.KEY1, Y.KEY2 FROM TAB1 X FULL OUTER JOIN TAB2 Y ON (X.KEY = Y.KEY2)
      ```

      - 좌, 우측 데이터 모든 읽어서 JOIN -> RIGHT + LEFT JOIN 합집합

      - 문제 : 동일 결과

        ```sql
        SELECT A.ID, B.ID FROM TBL1 A FULL OUTER JOIN TBL2 B ON A.ID = B.ID
        
        SELECT A.ID, B.ID 
        FROM TBL1 A LEFT OUTER JOIN TBL2 B ON A.ID = B.ID
        UNION
        FROM TBL1 A RIGHT OUTER JOIN TBL2 B ON A.ID = B.ID
        
        SELECT A.ID, B.ID 
        FROM TBL1 A, TBL2 B WHERE A.ID = B.ID UNION ALL
        SELECT A.ID, NULL 
        FROM TBL1 A WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID) UNION ALL
        SELECT NULL, B.ID
        FROM TBL2 B WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID) UNION ALL
        ```

    - 문제 : ITALIC -> PRIMARY KEY, EMP.C -> FK

      > - EMP
      >
      >   | *A*  |  B   |  C   |
      >   | :--: | :--: | :--: |
      >   |  1   |  b   |  w   |
      >   |  3   |  d   |  w   |
      >   |  5   |  y   |  y   |
      >
      > - DEPT
      >
      >   | *C*  |  D   |  E   |
      >   | :--: | :--: | :--: |
      >   |  w   |  1   |  10  |
      >   |  z   |  4   |  11  |
      >   |  v   |  2   |  22  |

      - LEFT : 3건

        |  A   |  B   |  C   |  D   |  E   |
        | :--: | :--: | :--: | :--: | :--: |
        |  1   |  b   |  w   |  1   |  10  |
        |  3   |  d   |  w   |  1   |  10  |
        |  5   |  y   |  y   |      |      |

      - RIGHT : 4건

        |  A   |  B   |  C   |  D   |  E   |
        | :--: | :--: | :--: | :--: | :--: |
        |  1   |  b   |  w   |  1   |  10  |
        |  3   |  d   |  w   |  1   |  10  |
        |      |      |  z   |  4   |  11  |
        |      |      |  v   |  2   |  22  |

      - FULL : 5건

        |  A   |  B   |  C   |  D   |  E   |
        | :--: | :--: | :--: | :--: | :--: |
        |  1   |  b   |  w   |  1   |  10  |
        |  3   |  d   |  w   |  1   |  10  |
        |  5   |  y   |  y   |      |      |
        |      |      |  z   |  4   |  11  |
        |      |      |  v   |  2   |  22  |

- 문제

  > student -> st_num (PK), department -> dept_num (PK)
  >
  > student - d_num (FK) -> department - dept_num
  >
  > ```sql
  > SELECT COUNT(st_name) FROM student s WHERE NOT EXISTS (SELECT * FROM department d WHERE s.d_num = d.dept_num AND dept_name = '전자계산학과');
  > ```
  >
  > - Student
  >
  >   | st_num | st_name | d_num |
  >   | :----: | :-----: | :---: |
  >   |  1001  |   Yoo   |  10   |
  >   |  1002  |   Kim   |  30   |
  >   |  1003  |   Lee   |  20   |
  >   |  1004  |  Park   |  10   |
  >   |  1005  |  Choi   |  20   |
  >   |  1006  |  Jeong  |  10   |
  >
  > - Department
  >
  >   | dept_num |  dept_name   |
  >   | :------: | :----------: |
  >   |    10    | 컴퓨터공학과 |
  >   |    20    | 원자력공학과 |
  >   |    30    | 전자계산학과 |

  | st_num | st_name | d_num |
  | :----: | :-----: | :---: |
  |  1001  |   Yoo   |  10   |
  |  1003  |   Lee   |  20   |
  |  1004  |  Park   |  10   |
  |  1005  |  Choi   |  20   |
  |  1006  |  Jeong  |  10   |

#### 제2절 집합 연산자

| 집합 연산자 |                         연산자 의미                          |
| :---------: | :----------------------------------------------------------: |
|    UNION    |  여러 개 SQL문 결과 합집합<br />-> 중복 행 : 하나의 행으로   |
|  UNION ALL  | 여러 개 SQL문 결과 합집합 <br />-> 중복 행도 그대로 => 단순히 결과만 합침<br />상호 배타적일 때 (exclusive) |
|  INTERSECT  |                교집합 -> 중복 : 하나의 행으로                |
|   EXCEPT    |        차집합 -> 중복 : 하나의 행으로 (일부 : MINUS)         |

- 문제 : 동일 결과

  > ```sql
  > SELECT A, B FROM TAB1 EXCEPT SELECT A, B FROM TAB2;
  > ```

  ```sql
  SELECT TAB1.A, TAB1.B FROM TAB1 WHERE TAB1.A NOT IN (SELECT TAB2.A FROM TAB2) AND TAB1.B NOT IN (SELECT TAB2.B FROM TAB2);
  ```

- 문제 : 동일 결과

  > [서비스] 서비스ID - 서비스명, 서비스URL ~ [서비스이용] 회원ID (FK), 서비스ID (FK) - 이용일시 ~ [회원] 회원ID - 회원명
  >
  > ```sql
  > SELECT A.서비스ID, B.서비스명, B.서비스URL FROM (SELECT 서비스 ID FROM 서비스 INTERSECT SELECT 서비스ID FROM 서비스이용) A, 서비스 B WHERE A.서비스ID = B.서비스ID;
  > ```

  ```sql
  SELECT X.서비스ID, X.서비스명, X.서비스URL FROM 서비스 X 
  WHERE NOT EXISTS (SELECT 1 FROM (SELECT 서비스ID FROM 서비스 MINUS SELECT 서비스ID FROM 서비스이용) Y
                   WHERE X.서비스ID = Y.서비스ID);
  ```

- 문제

  > ```sql
  > SELECT ENAME AAA, JOB AAB FROM EMP WHERE EMPNO = 7369 UNION ALL 
  > SELECT ENAME BBA, JOB BBB FROM EMP WHERE EMPNO = 7566 ORDER BY 1, 2;
  > ```
  >
  > - EMP
  >
  >   | EMPNO | ENAME  |    JOB    | MGR  |  HIREDATE  | SAL  | COMM | DEPTNO |
  >   | :---: | :----: | :-------: | :--: | :--------: | :--: | :--: | :----: |
  >   | 7369  | SMITH  |   CLERK   | 7902 | 1980-12-17 | 800  |      |   20   |
  >   | 7499  | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600 | 300  |   30   |
  >   | 7521  |  WARD  | SALESMAN  | 7698 | 1981-02-22 | 1250 | 500  |   30   |
  >   | 7566  | JONES  |  MANAGER  | 7839 | 1981-04-02 | 2975 |      |   20   |
  >   | 7654  | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250 | 1400 |   30   |
  >   | 7698  | BLAKE  |  MANAGER  | 7839 | 1981-05-01 | 2850 |      |   30   |
  >   | 7782  | CLARK  |  MANAGER  | 7839 | 1981-06-09 | 2450 |      |   10   |
  >   | 7788  | SCOTT  |  ANALYST  | 7566 | 1987-07-13 | 3000 |      |   20   |
  >   | 7839  |  KING  | PRESIDENT |      | 1981-11-17 | 5000 |      |   10   |
  >   | 7844  | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500 |  0   |   30   |
  >   | 7876  | ADAMS  |   CLERK   | 7788 | 1987-07-13 | 1100 |      |   20   |
  >   | 7900  | JAMES  |   CLERK   | 7698 | 1981-12-03 | 950  |      |   30   |
  >   | 7902  |  FORD  |  ANALYST  | 7566 | 1981-12-03 | 3000 |      |   20   |
  >   | 7934  | MILLER |   CLERK   | 7783 | 1982-01-23 | 1300 |      |   10   |

  |  AAA  |   AAB   |
  | :---: | :-----: |
  | JONES | MANAGER |
  | SMITH |  CLERK  |

- 문제

  > - TBL1
  >
  >   | COL1 | COL2 |
  >   | :--: | :--: |
  >   |  AA  |  A1  |
  >   |  AB  |  A2  |
  >
  > - TBL2
  >
  >   | COL1 | COL2 |
  >   | :--: | :--: |
  >   |  AA  |  A1  |
  >   |  AB  |  A2  |
  >   |  AC  |  A3  |
  >   |  AD  |  A4  |
  >
  > ```sql
  > SELECT COL1, COL2, COUNT(*) AS CNT
  > FROM (SELECT COL1, COL2 FROM TBL1 UNION ALL
  >      SELECT COL1, COL2 FROM TBL2 UNION
  >      SELECT COL1, COL2 FROM TBL1)
  > GROUP BY COL1, COL2;
  > ```

  | COL1 | COL2 | CNT  |
  | :--: | :--: | :--: |
  |  AA  |  A1  |  1   |
  |  AB  |  A2  |  1   |
  |  AC  |  A3  |  1   |
  |  AD  |  A4  |  1   |

- 문제 : 행의 수

  > - T1
  >
  >   |  A   |  B   |  C   |
  >   | :--: | :--: | :--: |
  >   |  A3  |  B2  |  C3  |
  >   |  A1  |  B1  |  C1  |
  >   |  A2  |  B1  |  C2  |
  >
  > - T2
  >
  >   |  A   |  B   |  C   |
  >   | :--: | :--: | :--: |
  >   |  A1  |  B1  |  C1  |
  >   |  A3  |  B2  |  C3  |
  >
  > ```sql
  > /* 가 */
  > SELECT A, B, C FROM R1 UNION ALL SELECT A, B, C FROM R2
  > 
  > /* 나 */
  > SELECT A, B, C FROM R1 UNION SELECT A, B, C FROM R2
  > ```

  - 가 : 중복 레코드 유지, 정렬 X

    |  A   |  B   |  C   |
    | :--: | :--: | :--: |
    |  A3  |  B2  |  C3  |
    |  A1  |  B1  |  C1  |
    |  A2  |  B1  |  C2  |
    |  A1  |  B1  |  C1  |
    |  A3  |  B2  |  C3  |

  - 나 : 중복 레코드 제거, 정렬 O

    |  A   |  B   |  C   |
    | :--: | :--: | :--: |
    |  A1  |  B1  |  C1  |
    |  A2  |  B1  |  C2  |
    |  A3  |  B2  |  C3  |

- 문제 

  > A, B 집합연산 -> C => 집합연산 ?
  >
  > A = {가, 나, 다, 라}, B = {다, 라, 마, 바}, C = {다, 라}

  - INTERSECTION

- 문제

  > [회원기본정보] - 회원ID ~ [회원상세정보] 회원ID (FK)
  >
  > 1:1, 양쪽 필수 관계

  - 회원ID -> (회원기본정보 EXCEPT 회원상세정보) => 공집합
  - 회원ID -> (회원기본정보 UNION ALL 회원상세정보) => 회원기본정보 전체건수 * 2
  - 회원ID -> (회원기본정보 INTERSECT 회원상세정보) = 회원ID -> JOIN 연산 = 회원ID -> (회원기본정보 UNION 회원상세정보)


#### 제3절 계층형 질의와 셀프 조인

- 계층형 질의

  - Oracle

    - PRIOR

      - CONNECT BY 절에 사용, 현재 읽은 칼럼 지정
      - PRIOR 자식 = 부모 -> 순방향 전개 : 부모 -> 자식
      - PRIOR 부모 = 자식 -> 역방향 전개 : 자식 -> 부모

    - START WITH : 계층 구조 전개 시작 위치 지정 -> 루트 데이터 지정 (액세스)

    - ORDER SIBLINGS BY : 형제 노드 사이 정렬 지정

    - 루트 노드 LEVEL = 1

    - WHERE : 모든 전개 진행 이후 필터 조건 -> 조건 만족 데이터만 추출

    - 문제

      > - TAB1
      >
      >   |  C1  |  C2  |  C3  |
      >   | :--: | :--: | :--: |
      >   |  1   |      |  A   |
      >   |  2   |  1   |  B   |
      >   |  3   |  1   |  C   |
      >   |  4   |  2   |  D   |
      >
      > ```sql
      > SELECT C3 FROM TAB1 START WITH C2 IS NULL CONNECT BY PRIOR C1 = C2 ORDER SIBLINGS BY C3 DESC;
      > ```

      |  C3  |
      | :--: |
      |  A   |
      |  C   |
      |  B   |
      |  D   |

    - 문제

      > - 사원
      >
      >   | 사원번호 (PK) | 사원명 |  입사일자  | 매니저사원번호 (FK) |
      >   | :-----------: | :----: | :--------: | :-----------------: |
      >   |      001      | 홍길동 | 2012-01-01 |        NULL         |
      >   |      002      | 강감찬 | 2012-01-01 |         001         |
      >   |      003      | 이순신 | 2013-01-01 |         001         |
      >   |      004      | 이민정 | 2013-01-01 |         001         |
      >   |      005      | 이병헌 | 2013-01-01 |        NULL         |
      >   |      006      | 안성기 | 2014-01-01 |         005         |
      >   |      007      | 이수근 | 2014-01-01 |         005         |
      >   |      008      | 김병만 | 2014-01-01 |         005         |
      >
      > ```sql
      > SELECT 사원번호, 사원명, 입사일자, 매니저사원번호 FROM 사원 START WITH 매니저사원번호 IS NULL
      > CONNECT BY PRIOR 사원번호 = 매니저사원번호 AND 입사일자 BETWEEN '2013-01-01' AND '2013-12-31'
      > ORDER SIBLINGS BY 사원번호;
      > ```

      | 사원번호 (PK) | 사원명 |  입사일자  | 매니저사원번호 (FK) |
      | :-----------: | :----: | :--------: | :-----------------: |
      |      001      | 홍길동 | 2012-01-01 |        NULL         |
      |      003      | 이순신 | 2013-01-01 |         001         |
      |      004      | 이민정 | 2013-01-01 |         001         |
      |      005      | 이병헌 | 2013-01-01 |        NULL         |

  - SQL Server

    - CTE (Common Table Expression) 재귀 호출

    - 앵커 멤버 실행 -> 기본 결과 집합 => 재귀 멤버 지속적 실행

    - 문제

      > - 부서
      >
      >   | 부서코드 (PK) |    부서명    | 상위 부서코드 (FK) |
      >   | :-----------: | :----------: | :----------------: |
      >   |      100      |   아시아부   |        NULL        |
      >   |      110      |   한국지사   |        100         |
      >   |      111      |   서울지점   |        110         |
      >   |      112      |   부산지점   |        110         |
      >   |      120      |   일본지사   |        100         |
      >   |      121      |   도쿄지점   |        120         |
      >   |      122      |  오사카지점  |        120         |
      >   |      130      |   중국지사   |        100         |
      >   |      131      |  베이징지점  |        130         |
      >   |      132      |  상하이지점  |        130         |
      >   |      200      |  남유럽지부  |        NULL        |
      >   |      210      |  스페인지사  |        200         |
      >   |      211      | 마드리드지점 |        210         |
      >   |      212      | 그라나다지점 |        210         |
      >   |      220      | 포르투갈지점 |        200         |
      >   |      221      |  리스본지점  |        220         |
      >   |      222      |  포르투지점  |        220         |
      >
      > - 매출
      >
      >   | 부서코드 | 매출액 |
      >   | :------: | :----: |
      >   |   111    |  1000  |
      >   |   112    |  2000  |
      >   |   121    |  1500  |
      >   |   122    |  1000  |
      >   |   131    |  1500  |
      >   |   132    |  2000  |
      >   |   211    |  2000  |
      >   |   212    |  1500  |
      >   |   221    |  1000  |
      >   |   222    |  2000  |
      >
      > - 결과
      >
      >   | 부서코드 |   부서명   | 상위 부서코드 | 매출액 | LVL  |
      >   | :------: | :--------: | :-----------: | :----: | :--: |
      >   |   100    |  아시아부  |     NULL      |  NULL  |  2   |
      >   |   120    |  일본지사  |      100      |  NULL  |  1   |
      >   |   121    |  도쿄지점  |      120      |  1500  |  2   |
      >   |   122    | 오사카지점 |      120      |  1000  |  2   |

      ```sql
      SELECT A.부서코드, A.부서명, A.상위부서코드, B.매출액, LVL
      FROM (SELECT 부서코드, 부서명, 상위부서코드, LEVEL AS LVL
           FROM 부서 START WITH 부서코드 = '120' CONNECT BY PRIOR 상위부서코드 = 부서코드 UNION
           SELECT 부서코드, 부서명, 상위부서코드, LEVEL AS LVL
           FROM 부서 START WITH 부서코드 = '120' CONNECT BY PRIOR 상위부서코드 = PRIOR 부서코드) A LEFT OUTER JOIN 매출 B ON (A.부서코드 = B.부서코드) ORDER BY A.부서코드;
      ```

- 셀프 조인

  - 한 테이블 내 두 칼럼이 연관 관계

  - 동일 테이블 사이 조인 -> FROM 절에 동일 테이블이 두 번 이상 => 식별 : 별칭 사용 (Alias)

  - 문제

    > WINDOW FUNCTION 사용 X 일자별 누적매출액
    >
    > - 일자별매출
    >
    >   |    일자    | 매출액 |
    >   | :--------: | :----: |
    >   | 2015.11.01 |  1000  |
    >   | 2015.11.02 |  1000  |
    >   | 2015.11.03 |  1000  |
    >   | 2015.11.04 |  1000  |
    >   | 2015.11.05 |  1000  |
    >   | 2015.11.06 |  1000  |
    >   | 2015.11.07 |  1000  |
    >   | 2015.11.08 |  1000  |
    >   | 2015.11.09 |  1000  |
    >   | 2015.11.10 |  1000  |
    >
    > - 일자별 누적매출액
    >
    >   |    일자    | 매출액 |
    >   | :--------: | :----: |
    >   | 2015.11.01 |  1000  |
    >   | 2015.11.02 |  2000  |
    >   | 2015.11.03 |  3000  |
    >   | 2015.11.04 |  4000  |
    >   | 2015.11.05 |  5000  |
    >   | 2015.11.06 |  6000  |
    >   | 2015.11.07 |  7000  |
    >   | 2015.11.08 |  8000  |
    >   | 2015.11.09 |  9000  |
    >   | 2015.11.10 | 10000  |

    ```sql
    SELECT A.일자 (SELECT SUM(B.매출액) FROM 일자별매출 B WHERE B.일자 >= A.일자) AS 누적매출액 FROM 일자별매출 A GROUP BY A.일자 ORDER BY A.일자;
    ```

#### 제4절 서브쿼리

![sql가이드](C:\Users\j2woo\Desktop\ssafy6\TIL\img\SQL_214.jpg)

- 종류

  |           종류           |                             설명                             |
  | :----------------------: | :----------------------------------------------------------: |
  |   Single Row (단일 행)   | 실행 결과 1건<br />비교 연산자 : `=`, `<`, `<=`, `>`, `>=`, `<>` |
  |   Mutli Row (다중 행)    | 실행 결과 여러 건<br />비교 연산자 : IN, ALL, ANY, SOME, EXISTS |
  | Multi Column (다중 칼럼) | 여러 칼럼 반환<br />메인쿼리 조건절 -> 여러 칼럼 동시 비교<br />칼럼 개수, 위치 동일 |

- 비 연관 서브쿼리

  - 메인쿼리에 값 제공하기 위한 목적

- Inline View

  - FROM 절에서 사용
  - 결과가 실행 시에 동적으로 생성된 테이블인 것처럼 사용
  - SQL 실행될 때만 임시적 생성 동적 뷰 -> DB에 저장 X

- 문제

  > ```sql
  > SELECT COUNT(DISTINCT A||B) FROM EMP WHERE D = (SELECT D FROM DEPT WHERE E = 'i');
  > ```
  >
  > - EMP
  >
  >   |  A   |  B   |  C   |  D   |
  >   | :--: | :--: | :--: | :--: |
  >   |  1   |  a   |  1   |  x   |
  >   |  2   |  a   |  1   |  x   |
  >   |  3   |  b   |  2   |  y   |
  >
  > - DEPT
  >
  >   |  D   |  E   |  F   |
  >   | :--: | :--: | :--: |
  >   |  x   |  i   |  5   |
  >   |  y   |  m   |  6   |

  - `(SELECT D FROM DEPT WHERE E = 'i')` -> [DEPT] D 컬럼 값 x인 행
  - `D = (SELECT D FROM DEPT WHERE E = 'i')` -> [EMP] (A=1, B=a), (A=2, B=a)

- 문제

  > 현재 부양하는 가족들이 없는 사원들의 이름
  >
  > [사원] **사번**, 이름, 나이
  >
  > [가족] **이름**, 나이, *부양사번*

  ```sql
  /* NOT EXISTS */
  SELECT 이름 FROM 사원 WHERE NOT EXISTS (SELECT * FROM 가족 WHERE 사번 = 부양사번)
  
  /* NOT IN */
  SELECT 이름 FROM 사원 WHERE NOT IN (SELECT 부양사번 FROM 가족)
  
  /* LEFT OUTER JOIN */
  
  SELECT 이름 FROM 사원 LEFT OUTER JOIN 가족 ON (사번 = 부양사번) WHERE 부양사번 IS NULL
  ```

- 문제

  > 동일 결과
  >
  > [회원] 회원번호 - 회원명 ~ [동의항목] 회원번호 (FK), 약관항목코드 (FK) - 동의여부, 동의일시 ~ [약관항목] 약관항목코드 - 약관명
  >
  > ```sql
  > SELECT A.회원번호, A.회원명 FROM 회원 A, 동의항목 B WHERE A.회원번호 = B.회원번호
  > GROUP BY A.회원번호, A.회원명 HAVING COUNT(CASE WHEN B.동의여부 = 'N' THEN 0 ELSE NULL END) >= 1
  > ORDER BY A.회원번호;
  > ```

  ```sql
  SELECT A.회원번호, A.회원명 FROM 회원 A WHERE EXISTS (SELECT 1 FROM 동의항목 B WHERE A.회원번호 = B.회원번호 AND B.동의여부 = 'N') ORDER BY A.회원번호;
  
  SELECT A.회원번호, A.회원명 FROM 회원 A WHERE A.회원번호 IN (SELECT B.회원번호 FROM 동의항목 B WHERE B.동의여부 = 'N') ORDER BY A.회원번호;
  
  SELECT A.회원번호, A.회원명 FROM 회원 A, 동의항목 B WHERE A.회원번호 = B.회원번호 AND B.동의여부 = 'N'
  GROUP BY A.회원번호, A.회원명 ORDER BY A.회원번호;
  ```

- 문제

  > [회원] 회원ID - 회원명, 가입일시, 이메일 ~ [메일발송] 이벤트ID (FK), 회원ID (FK) - 발송일시 ~ [이벤트] 이벤트ID - 이벤트명, 시작일자, 종료일자, 내용
  >
  > ```sql
  > SELECT A.회원ID, A.회원명, A.이메일 FROM 회원 A
  > 
  > /* ㄱ */
  > WHERE EXISTS (SELECT 'X' FROM 이벤트 B, 메일발송 C WHERE B.시작일자 >= '2014.10.01' AND B.이벤트ID = C.이벤트ID)
  > 
  > /* ㄴ */
  > AND A.회원ID = C.회원ID
  > 
  > /* ㄷ */
  > HAVING COUNT(*) < (SELECT COUNT(*) FROM 이벤트 WHERE 시작일자 >= '2014.10.01');
  > ```

  - ㄷ : 이벤트 시작일자가 `2014/10/01`과 같거나 큰 이벤트 건수와 그 이벤트 기준 이메일 발송이 누락된 회원 추출

- 문제

  > ```sql
  > SELECT B.사원번호, B.사원명, A.부서번호, A.부서명, 
  > (SELECT COUNT(*) FROM 부양가족 Y WHERE Y.사원번호 = B.사원번호) AS 부양가족수
  > FROM 부서 A, (SELECT * FROM 사원 WHERE 입사년도 = '2014') B
  > WHERE A.부서번호 = B.부서번호 AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 = A.부서번호);
  > ```

  - 2014년에 입사한 사원들의 사원, 부서 정보오 부양가족수
  - SELECT 절 -> 단일행 연관 서브쿼리, JOIN으로 변경 가능
  - FROM 절 -> Inline (Dynamic) View
  - WHERE 절 -> 다중행 연관 서브쿼리

- 문제

  > 평가대상상품에 대한 품질평가항목별 최종 평가 결과
  >
  > 평가등급이 기대수준에 미치지 못할 경우 해당 평가항목에 대해서 재평가
  >
  > [품질평가항목] 평가항목ID - 평가항목명 ~ [평가결과] 상품ID (FK), 평가회차, 평가항목ID (FK) - 평가등급, 평가일자 ~ [평가대상상품] 상품ID - 상품명

  ```sql
  SELECT B.상품ID, B.상품명, C.평가항목ID, C.평가항목명, A.평가회차, A.평가등급, A.평가일자
  FROM 평가결과 A, 평가대상상품 B, 품질평가항목 C 
  WHERE A.상품ID = B.상품ID AND A.평가항목ID = C.평가항목ID AND A.평가회차 = (
      SELECT MAX(X.평가회차) FROM 평가결과 X WHERE X.상품ID = B.상품ID AND X.평가항목ID = C.평가항목ID);
  ```

- 문제

  > 담당자 변경 -> 부서임시 테이블 데이터 => 주기적으로 부서 테이블 결과 반영
  >
  > 부서임시 테이블에서 변경일자 기준 가장 최근에 변경된 데이터 기준으로 부서 테이블에 반영
  >
  > - 부서
  >
  >   | 부서코드 (PK) |    부서명    | 상위부서코드 | 담당자 |
  >   | :-----------: | :----------: | :----------: | :----: |
  >   |     A001      |   대표이사   |     NULL     | 김대표 |
  >   |     A002      |   영업본부   |     A001     | 홍길동 |
  >   |     A003      | 경영지원본부 |     A001     | 이순신 |
  >   |     A004      |  마케팅본부  |     A001     | 강감찬 |
  >   |     A005      |  해외영업팀  |     A002     | 이청용 |
  >   |     A006      |  국내영업팀  |     A002     | 박지성 |
  >   |     A007      |    총무팀    |     A003     | 차두리 |
  >   |     A008      |    인사팀    |     A003     | 이민정 |
  >   |     A009      | 해외마케팅팀 |     A004     | 이병헌 |
  >   |     A010      | 국내마케팅팀 |     A004     | 차승원 |
  >
  > - 부서임시
  >
  >   | 변경일자 (PK) | 부서코드 (PK) | 담당자 |
  >   | :-----------: | :-----------: | :----: |
  >   |  2014.01.23   |     A007      | 이달자 |
  >   |  2015.01.25   |     A007      | 홍경민 |
  >   |  2015.01.25   |     A008      | 유재석 |
  >
  > - 결과
  >
  >   | 부서코드 (PK) |    부서명    | 상위부서코드 | 담당자 |
  >   | :-----------: | :----------: | :----------: | :----: |
  >   |     A001      |   대표이사   |     NULL     | 김대표 |
  >   |     A002      |   영업본부   |     A001     | 홍길동 |
  >   |     A003      | 경영지원본부 |     A001     | 이순신 |
  >   |     A004      |  마케팅본부  |     A001     | 강감찬 |
  >   |     A005      |  해외영업팀  |     A002     | 이청용 |
  >   |     A006      |  국내영업팀  |     A002     | 박지성 |
  >   |     A007      |    총무팀    |     A003     | 홍경민 |
  >   |     A008      |    인사팀    |     A003     | 유재석 |
  >   |     A009      | 해외마케팅팀 |     A004     | 이병헌 |
  >   |     A010      | 국내마케팅팀 |     A004     | 차승원 |

  ```sql
  UPDATE 부서 A SET 담당자 = (
      SELECT B.담당자 FROM 부서임시 B WHERE B.부서코드 = A.부서코드 AND B.변경일자 = (
          SELECT MAX(C.변경일자) FROM 부서임시 C WHERE C.부서코드 = B.부서코드))
          WHERE 부서코드 IN (SELECT 부서코드 FROM 부서임시);
  ```

  

#### 제5절 그룹 함수

#### 제6절 윈도우 함수

#### 제7절 DCL

#### 제8절 절차형 SQL